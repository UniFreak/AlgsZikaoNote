# 概论

NOTE:
- i 从 1 开始...
- 命名: ListSize -> listSize
- 注释: p.
- 书中错误: @err
- main 简单的用例测试
- dump
- *Test.c

TODO:
- test.sh: test.sh *, test LinkStack...

Learn:
- malloc, 指针, NULL 对于初始化的作用

## 数据结构

好的算法必须建立在研究数据的特性及数据之间存在的关系的基础之上.

**数据结构**一般包括三方面内容
- 数据之间的逻辑 (或抽象) 关系, 即**逻辑结构**. 包括*
    + **线性结构** (如线性表, 栈, 队列)
    + **非线性结构** (如树, 图)
- 数据元素及其关系在计算机内的存储方式, 即**存储结构(物理结构)**
    + **顺序存储**: 逻辑上相邻的点在物理位置上也相邻. 通常用于线性结构数据, 但非线性结构也可以通过线性化方法用顺序存储
    + **链接存储**: 元素间的关系用附加的指针域表示, 物理位置不一定连续
    + **索引存储**: 存储元素的通史, 附加建立一份索引表
    + **散列存储**: 根据元素关键字直接计算出元素的存储地址
- 数据的**运算**, 如增删改查等

    运算的具体实现是在存储结构上进行的, 因此在逻辑结构上定义的运算, 只要给出运算的功能是 "做什么", 至于 "怎么做" 等实现细节, 只有待确定了存储结构之后才能考虑

    对于不同问题, 需要的运算可能不同.

    复杂的运算, 可用基本运算的组合来实现.


数据结构 VS 数据类型 VS 抽象数据类型 (ADT)
- 数据类型可看作是程序设计语言中已实现的数据结构
- 抽象数据类型可看做是描述问题的模型, 它独立于具体实现. 等价于在数据的逻辑结构以及在逻辑结构上定义的抽象操作

## 算法

**算法**是对问题求解步骤的描述. 必须满足以下**五个准则**:
1. 给定输入
2. 至少有一个或多个输出
3. 有穷: 每个步骤的执行次数必须有限, 且在又穷时间内完成
4. 确定: 每个步骤的含义明确无二义
5. 可行: 每个步骤都可以通过有限次的基本运算来实现

算法不依赖于计算机程序语言, 可用自然语言, 程序语言, 约定的符号语言等描述.

对算法的评价和**分析**包括:
- 最主要的是**时间复杂性**, 即算法耗费的时间
- **空间复杂性**, 即算法耗费的存储空间
- 可读性和可操作性

# 线性表

定义: 由 n 个数据元素组成的有限序列. 数据元素的个数 n 为表的长度. 当 n 为 0 时称为空表.

逻辑特征
- 有且仅有一个开始元素, 它没有前趋, 仅有一个直接后继
- 有且仅有一个终端元素, 它没有后继, 仅有一个直接前趋
- 其余元素称为内部元素, 它们都有且仅有一个直接前趋和一个直接后继
- 这种相邻关系又称为线性关系, 可见线性表是一种典型的线性结构


## 顺序存储

使用顺序存储的线性表称为**顺序表**. 它的特点是:
- 只要知道基地址和每个元素占用的单元数, 就可求出任一元素的地址
- 任意元素都可随机存取 (存取某个位置的元素不必事先存取其前一个元素), 顺序表是一种随机存取结构

缺点: 需要移动大量元素 -> 链式存储

通常用数组来描述顺序表

基本运算: @see SeqList.c

## 链式存储

缺点:
链表的结点不可以随机存取

链式存储不仅可以用来表示线性表, 还可以用来表示各种非线性的数据结构.

### 单链表

链表: 元素由两部分组成:
数据域: 存储数据元素
指针域: 存储直接后继地址

用这种存储方式表示的线性表称为链表. 每个结点只包含一个指针域, 因此又称为单链表.
终端结点的指针域为空, 即 NULL
设立头指针指向开始结点.
如果链表中一个结点都没有, 则为空链表. 此时头指针为 NULL

一个单链表可由头指针唯一确定, 因此单链表可以用头指针的名字来命名.
为方便操作, 可以在开始结点之前附加一个 **头结点**.

存取第 i 个结点时, 必须从表头结点开始搜索, 所以链表结构是非随机存取存储结构. 若链表带头结点时, 就应特别注意头结点和表头结点 (即开始结点) 的区别.

基本运算: @see LinkList.c

### 循环链表

**循环链表**是链式存储的另一种形式, 它的特点
- 单链表中最后一个结点的指针域不为空, 而是指向链表的头结点, 是整个链表构成一个环
- 从表中任一结点开始都可以访问表中的其他结点

可有单循环链表, 还可以有多重链的循环链表

它的结点类型与单链表完全相同, 在操作上也与单链表基本一致, 差别仅在于算法中循环结束判断条件不再是 p 或 p->next 是否为空, 而是他们是否等于头指针.


@see CycleLinkList.c

### 双向链表

向单向链表的结点类型中, 增加一个指向其直接前趋的指针域, 这样形成的链表为**双向链表**.

双向链表可以从表中快速确定一个结点的直接前趋.

@see DLinkList.c

双链表中增设一个头结点, 将尾结点和头结点链接起来就构成了**双向循环链表**

# 栈和队列

## 栈

**栈**是一种限定在表的一端进行插入和删除运算的线性表. 将插入, 删除的一端称为栈顶, 另一端称为栈底. 栈又称为后进先出 (LIFO) 表. 插入称为**进栈**, 删除称为**退栈**.

栈的顺序存储结构称为**顺序栈**, 类似于顺序表, 顺序栈也使用数组实现. 一般将栈底设置在数组最低端 (下标 0), 并设置栈顶指针指示栈顶位置.

当栈满时, 进栈会导致**上溢**; 当栈空时, 退栈会导致**下溢**.

@see SeqStack.c

如果将多个栈分配在同一个顺序存储空间内, 则可以相互进行调节, 即节约空间, 又可降低发生溢出的概率. 可以将两个栈的栈底分别设在顺序存储空间的两端, 让两个栈各自向中间延伸.

---

栈的链式存储结构称为**链栈**, 它是运算受限的单链表. 不必设置头结点. 可以克服顺序栈的溢出和空间浪费问题.

---

栈的应用非常广泛, 只要问题满足 LIFO 原则, 都可使用栈作为数据结构, 如
- 圆括号匹配的检验 @see SeqStack.c:Expr
- 字符串回文的判断 @see SeqStack.c:symmetry
- 数值转换 @see SeqStack.c:conversion
- 通过递归工作栈, 实现递归
- 实现程序设计语言的函数调用和返回

## 队列

**队列**也是一种操作受限的线性表, 它只允许在表的一端进行插入, 而在另一端进行删除. 插入的一端称为**队尾**, 删除的一端称为**队头**. 元素的插入称为**入队**, 删除称为**出队**. 又称队列为**先进先出 (FIFO) 表**.

队列的顺序存储结构称为**顺序队列**. 需要设置队头指针 front 和队尾指针 rear. 它们的初值为 0.
入队时, 将元素插入队尾指针所指位置, 并将队尾指针加 1.
出队时, 将队头指针加 1, 并返回被删除的元素.
头尾指针相等时队列为空.

@see SeqQueue.c

如果用数组实现顺序队列, 当队尾指针指向数组最后一个元素时, 继续插入新元素, 则会发生上溢, 而出队的位置又无法再利用. 为了克服这两个问题, 可将数组想象为一个环状空间, 称这种环状数组表示的队列为**循环队列**.
- 可用求余运算, 判断发生上溢时, 进入下一个循环.
- 队列无论是空是满, 都有 队头指针 == 队尾指针.

    为了判断队列是空是满, 有几种常用方法:
    - 另设一个标志位, 标记队列是空是满
    - 设置计数器记录队列中元素个数
    - 少用一个元素空间, 即 rear 所指向的单元始终为空. 约定入队前, 测试 rear + 1 是否等于头指针. 是则队满.

@see CirQueue.c

---

队列的链式存储结构称为**链队列**.
需增设一个尾指针以方便在表尾做插入操作.
于是一个链队列就由一个头指针和一个尾指针唯一确定.
为了简化边界条件的处理, 队头结点之前也附加一个头结点, 并设头指针指向此结点.

@todo 图

@see LinkQueue.c

---

用一个带头结点的循环单链表表示队列, 成为**循环链队列**.

该队列只设一个队尾结点指针 rear, 不设头指针. 且 rear->next 回指到头结点.

@see CirLinkQueue.c

---

栈和队列的应用实例: 中缀表达式的计算

我们平时写的计算式如 8+5*(7-3), 因为运算符放到操作数中间, 称为**中缀表达式** (逆波兰表示法). 为了方便计算机处理, 可以把运算符放到操作数后面, 即**后缀表达式**. 如 8 5 7 3 - * +. 要计算该表达式, 可以从左向右扫描, 直到遇到一个运算符后即开始运算. 遇到 -, 计算 7-3, 得到 4, 原计算式变为 854*+; 遇见 *, 计算 5*4=20, 计算式变为 8 20 +; 遇见 +, 计算 8 + 20 = 28. 得到了最终结果. 后缀表达式的这种计算规则, 正是运用栈和队列的典型例子.

- 先通过栈将中缀表达式变为后缀表达式:

    从例子中可以看到, 将中缀表达式变为后缀表达式时, 运算符依据优先级从高到低从左向右的排列. 转换过程如下:
    1. 顺序扫描中缀表达式, 遇到数字时, 将其送至输出队列中
    2. 遇到运算符时, 将栈中所有优先级高于或等于该运算符的运算符弹出, 送至输出队列, 再将当前运算符入栈
    3. 遇到左括号时, 入栈
    4. 遇到右括号时, 将靠近栈顶的第一个左括号上面的运算符全部依次弹出, 送至输出队列中, 再删除栈中的左括号

- 然后计算后缀表达式

    因为运算符已经按照优先级顺序排好, 所以很容易用计算机实现. 因为计算后缀表达式时, 最后保存的值最先取出参与运算, 所以需要栈保存中间结果.

@see PostExp.c

# 多维数组和广义表

## 多维数组

当数组维数为 1 时, 它是一种元素个数固定的线性表. 当是多维数组时, 它可以看成是线性表的推广. 以二维数组为例:

    a1 a2 a3 a4
    b1 b2 b3 b4
    c1 c2 c3 c4

- 除了边界元素外, 每个元素都有分别位于行向量上和列向量上的两个直接前趋和两个直接后继. 如 b2 的两个直接前趋为 b1 和 a2, 两个直接后继为 b3 和 c2
- 开始结点 (a1) 没有前趋, 终端结点 (c4) 没有后继
- 边界上的结点只有行或列上的一个直接前趋或一个直接后继. 如 b1 只有一个前趋结点 a1, b4 只有一个后继结点 c4

@see Array.c

## 矩阵的压缩存储

矩阵一般用数组来存储.

**特殊矩阵**指的是相同值的元素或者零元素在矩阵的分布有一定规律的矩阵. 可以对这类矩阵采取压缩存储.

---

**对称矩阵**: 元素关于主对角线对称分布. 则只需要存储矩阵上三角或下三角元素. 如下面的矩阵

    00
    10  11
    20  21  22
    ...

假设行数为 n, 可以看出, 如果把上面的矩阵存储到一维数组中, 则总共需要 n(n+1)/2 个空间.

而且矩阵中元素 ij 对应到以为数组位置 k 有如下关系:
- 如果 i>=j, 则 ij 位于下三角: `k = i * (i + 1) / 2 + j`
- 如果 i<j,  则 ij 位于上三角: `k = j * (j + 1) / 2 + i`

@see SymMatrix.c

---

**三角矩阵**指矩阵的对角线上方或下方均为常数或零的方阵. 分别称为下三角矩阵或上三角矩阵.

比之对称矩阵, 需额外存储重复的元素. 故需要 n(n+1)/2+1 个空间.

对于上三角矩阵, 矩阵元素 ij 对应到数组位置 k 的关系为:
- 如果 i<=j, 则 ij 位于上三角: `k = i * (2n - i + 1) / 2 + j - i`
- 如果 i>j, 则存储于最后一项: `k = n (n + 1) / 2`

对于下三角矩阵, 矩阵元素 ij 对应到数组位置 k 的关系为:
- 如果 i>=j, 则 ij 位于下三角, 类似对称矩阵: `k = i * (i + 1) / 2 + j`
- 如果 i>j, 则存储于最后一项: `k = n (n + 1) / 2`

---

**稀疏矩阵**是非零元素的分布没有规律的矩阵, 因此在存储非零元素值时, 还需同时存储该元素的行列位置, 所以可用一个称为三元组 `(i, j, a[i][j])` 来唯一确定一个非零元素. 对稀疏矩阵的压缩存储通常有顺序存储和链式存储两种方法.
- 链式存储一般用十字链表法, 比较复杂, 不做介绍
- 顺序存储: 将三元组按行优先的顺序排列, 可得到一个其结点均为三元组的线性表, 称为**三元组表**


为了便于随机存取**任一行**的非零元素, 可以在三元组表表示的系数矩阵中额外存储每一行的第一个非零元素在三元组表中位置的数组. 这样的表示叫做**带行表的三元组表**, 又称为**行逻辑连接的顺序表**.


@see TSMatrix.c

## 广义表基础

**广义表**是线性表的推广, 又称列表. 线性表中的元素仅限于原子项, 如果放松这种限制, 允许它们自身具有结构, 就产生了广义表的概念. 广义表是 n 个元素的有限序列, 其中的元素或者是原子项, 或者是一个广义表. n 为它的长度, 内层的广义表称作**字表**. 嵌套的层数称为它的**深度**. 称第一个元素为表头, 称**其余元素组成的表**为**表尾**. 显然, 广义表是一个递归定义, 它是一种多层次的非线性结构. 它不仅是线性表的推广, 也是树结构的推广.

广义表通常记为 LS=(a1, a2, ..., an).

注意, () 和 (()) 是不同的. 前者是空表, 长度为 0, 后者是由空表做元素的广义表, 长度为 1.

通常采用链式存储结构表示广义表.

@see GList.c

# 树和二叉树

树形结构是一个递归结构. **树**是 n(n>=0) 个结点的有限集. 它是空集, 或者是非空集. 对于任意一棵非空树:
- 有且仅有一个特定的称为**根**的结点
- 当 n > 1 时, 其余结点可分为互不相交的有限集, 其中每个集合本身又是一棵树, 并称为根的**子树**

一般可以用以下几种表示法表示一棵树:
- 树形图表示法
- 嵌套集合的形式
- 凹形表示法
- 广义表形式

@todo 图

树的**结点**包含一个数据元素及若干个指向其子树的**分支**. 一个结点的子树数叫做结点的**度**. 最大的度称为该树的度. 度数为零的结点称为**叶子**结点或**终端**结点, 不为零的称为**非终端**结点或**分支结点**. 分支结点也叫内部节点, 而根结点又称为开始结点.

## 二叉树

**二叉树**的每个结点至多只有两颗子树. 并分别叫做根的左子树和右子树. 它可以是空集.

性质:
- 第 i 层至多有 2^(i-1) 个结点
- 深度为 k 的二叉树至多有 2^k-1 个结点. 把有 2^k-1 个结点的树叫做**满二叉树**
- 终端结点数等于度数为 2 的结点数再加 1
- 具有 n 个结点的完全二叉树的深度为 floor(logN) + 1 或 ceil(log(N+1))

**完全二叉树**只深度为 k 的二叉树, 前 k-1 层是一颗满二叉树, 而最下一层的结点都集中在最左边的若干位置.

对于具有 N 个结点的完全二叉树, 从树根开始自上到下自左到右的为每个结点编号, 则可以根据编号 i 可推导其父结点和子结点编号:
- 若 i=0, 则该结点为根结点, 无双亲. 若 i != 0, 则该结点的双亲编号为 floor((i-1)/2)
- 若 2i+1 < n, 则该结点的左孩子结点编号为 2i+1, 否则无左孩子, 即该结点必定是叶子结点
- 若 2i+2 < n, 则该结点的右孩子结点编号为 2i+2, 否则无右孩子

顺序存储结构
对于完全二叉树来说, 顺序存储结构既简单有节省存储空间. 而且对于插入和删除操作, 需要移动大量结点.
对于一般的二叉树, 必须增加一些虚结点使其成为完全二叉树, 这样的话会造成存储空间上的浪费.

链式存储结构
设计不同的结点可构成不同形式的链式存储结构. 通常是为每个结点设置三个域, 值域, 左指针域和右指针域. 有时为了便于查找结点双亲, 还可以增加一个指向双亲的指针.

称为**二叉链表**.

@see BinTree.c

遍历二叉树是二叉树中所有其他运算的基础. 所谓遍历, 指沿着某条搜索路径一次对树中每个节点访问, 且仅访问一次.
遍历一颗二叉树可分解为三步: 访问根结点 D, 遍历左子树 L, 和遍历右子树 R. 则有 DLR,  LDR, LRD 和 DRL, RDL, RLD 六种次序的遍历方案. 由于后三种和前三种对称, 仅讨论前三种.

DLR: 在访问子树前访问根结点, 称为**前序遍历**或**先根遍历**. 类似的
LDR: **中序遍历**
LRD: **后序遍历**

由二叉树的中序和前序遍历序列, 或者中序和后序遍历序列, 可唯一的确定一颗二叉树. 具体方法如下:
1. 根据前序或后续序列确定二叉树的各子树的根
2. 根据中序序列确定各子树根的左右子树

如前序序列为 abdeghcfi, 中序序列为 dbgehacif, 求二叉树:
1. 前序序列确定二叉树的根为 a, 再由中序序列确定 a 的左右子树
- a | bdegh | cfi     前序序列确定: 根, 左子树,右子树
- dbgeh | a | cif     中序序列确定: 左子树, 根, 右子树
2. 确定 a 的左子树
- b | d | egh         前序序列确定: 根, 左子树, 右子树
- d | b | geh         中序序列确定: 左子树, 根, 右子树
3. 再确定 b 的右子树: 唯一确定 e 为根, g 和 h 分别为左子树和右子树
- e | g | h           前序序列确定: 根, 左子树, 右子树
- g | e | h           中序序列确定: 左子树, 根, 右子树
4. 确定 a 的右子树
- c | fi              前序序列确定: 根, 右子树
- c | if              中序序列确定: 根, 右子树
5. 确定 c 的右子树
- f | i               前序序列确定: 根, 左子树
- i | f               中序序列确定: 左子树, 根

最终确定的树如下:

            a
          /   \
        b      c
      /  \       \
    d     e        f
         /  \     /
        g    h   i

## 线索二叉树

遍历二叉树以得到一个线性序列, 实质上是对一个非线性结构的**线性化操作**, 使得每个结点在序列中有且仅有一个直接前趋和一个直接后继.

使用二叉链表存储二叉树时, 因为每个结点之后指向左右子树的指针域, 不方便其前趋和后继结点的查找. 为了找到结点的直接前趋和后继, 可以在每个结点中增加前趋指针和后继指针域. 但这样会降低存储空间利用率.

另一方面. n 个结点的二叉链表中必定存在 n+1 个空指针域 (因为 n 个结点一共有 2n 个指针, 其中根结点不占用指针, 所以占用的指针为 n-1 个, 还剩 2n-(n-1)=n+1 个空指针域), 可以利用这些空指针域存放前趋和后继指针, 这些指针称为**线索**. 相应的二叉链表称为**线索链表**, 相应的二叉树称为**线索二叉树**. 而加线索的过程即**线索化**.

按照某种次序遍历二叉树, 遍历过程中用线索取代空指针即可实现线索化.

@see BinThrTree.c

## 树和森林

@see Tree.c

存储结构: @TODO image

双亲表示法: 树结构中每个结点的双亲是唯一的. 如果以一组连续空间 (数组) 存储树的结点, 同时为每个结点附加一个指向双亲的指针, 就可唯一的表示一棵树. 这种表示法方便查找双亲操作.

孩子链表法: 把每个结点的孩子结点看成一个线性表, 并以单链表结构存储其孩子结点. n 个结点就有 n 个孩子链表. 为了便于查找, 将树中各结点的孩子链表的头结点存放在一个指针数组中. 这种表示法方便查找孩子结点操作.

带双亲的孩子链表法: 将上述两种表示法结合起来, 既方便查找双亲, 也方便查找孩子.

孩子兄弟表示法: 又称二叉链表表示法. 即以二叉链表作为树的存储结构. 链表中两个链指针域分别指向该结点的第一个孩子结点和下一个兄弟结点. 这种方式的优点是, 它和二叉链表表示完全一样, 可利用二叉树的各种算法实现对树的操作.

---

给定一棵树, 可以找到唯一的一颗二叉树与之对应. 从物理结构上看它们是相同的, 只是解释不同而已.

将树转换为二叉树:
1. 首先在所有兄弟结点之间加一道线
2. 然后再对每个结点保留长子的连线, 去掉该结点与其他孩子的连线

将森林转换为二叉树:
1. 先将每一棵树转化成二叉树
2. 再将二叉树的根节点看作是兄弟连在一起, 形成一颗二叉树

将二叉树转换成树或森林:
1. 若结点 x 是双亲 y 的左孩子, 则把 x 的右孩子, 右孩子的右孩子... 都与 y 连起来
2. 去掉所有双亲到右孩子的连线

---

树的遍历

- 前序遍历

    先访问树的根结点, 然后依次前序遍历根的每颗子树.
    等价于前序遍历该树对应的二叉树

- 后序遍历

    限一次后序遍历根的每颗子树, 然后访问根结点
    等价于中序遍历该树对应的二叉树

森林的遍历

- 前序遍历

    从左到右依次按前序次序遍历森林中的每一棵树
    等价于前序遍历森林对应的二叉树

- 后序遍历

    从左到右依次按后序次序遍历森林中的每一棵树
    等价于中序遍历森林对应的二叉树

## 哈弗曼树

@see HuffmanTree.c

两个节点构成的路径上的边的数目称为**路径长度**. 树根到树中每个节点的路径长度称为**树的路径长度**.

为结点赋上具有某种意义的数, 称为该结点的**权**. 从树根结点到某结点之间的路径长度与该结点的权的乘积称为该结点的**带权路径长度**. 树中所有叶子结点的带权路径长度之和称为**树的带权路径长度**.

带权路径长度最小的二叉树称为**哈弗曼树**或**最优二叉树**.
一般利用哈夫曼树可以得到最佳的判定算法.

若叶结点上的权值均相同, 其中完全二叉树一定是最优二叉树, 否则不一定是最优二叉树.

利用哈夫曼算法可以构造最优二叉树. 步骤如下:
1. n 个带权值的相互孤立的叶子结点, 组成一个森林
2. 选出两个权值最小的结点, 作为左右子树, 构成一个新树. 置新树的根结点为左右子树的权值之和
3. 从森林中删除刚才选出的两个节点, 把新树加入到森林
4. 重复 2, 3. 直到森林中只剩下一棵树为止, 这棵树就是哈夫曼树

可见, n 个叶子结点需要合并 n-1 次, 产生 n-1 个新结点, 因此最终的哈弗曼树含有 2n-1 个结点.

---

对于 n 中字符, 根据其在报文中出现的频率, 作为其权, 然后构造一颗哈弗曼树. 把树中的做分支约定为 0, 右分支约定为 1, 取每条路径上的 0, 1 序列作为叶子结点对应字符的字符编码. 这就是**哈弗曼编码**.

哈夫曼编码也是一种**前缀编码**, 即保证任意字符的编码都不是另一个字符编码的前缀.

# 图

**图**是一种复杂的非线性结构. 在图形结构中, 结点之间的关系可以是任意的.

若图中每条边都是有方向的, 则该图为**有向图**. 连接两个结点的边则为**有向边**. 有向边又称为**弧**, 边的起点称为**弧尾**, 终点称为**弧头**.

若每条边都没有方向, 则该图为**无向图**.

边两端的结点互为**邻接点**, 或称它们彼此**相邻接**.

无向图边数的取值范围是 0~n(n-1)/2, 具有 n(n-1)/2 个边的无向图称为 **无向完全图**.
有向图边数的取值范围是 0~n(n-1), 具有 n(n-1) 个边的有向图称为 **有向完全图**.

顶点的**度**即以该顶点为端点的边的数目, 对于有向图, 分为**入度** (以顶点为终点的入边数目) 和**出度** (以顶点为起点的出边数目).

无论无向图还是有向图, 边数等于所有边的度数之和的一半.

如果沿着图中的边可从顶点 P 到顶点 Q, 则称存在一条**路径**, 且这两个顶点是 **连通** 的. 如果除了起点和终点可为同一个顶点外, 其余顶点均不相同, 称为 **简单路径**. 否则称路径为 **回路** 或 **环**.

如果无向图中任意两个顶点都连通, 称无向图为**连通图**. 无向图的极大连通子图称为 **连通分量**, 显然, 任何连通图的连通分量只有其自身. 而非连通图的无向图有多个连通分量.

如果有向图中任意两个顶点都连通, 则称有向图为 **强连通图**. 有向图中的极大连通子图称为 **强连通分量**.

若在边上标上具有某种意义 (距离, 时耗等) 的数值, 该数值称为该边的 **权**. 带权的图称为 **带权图**. 带权的连通图称为 **网络**.

## 存储结构

@see MGraph.c

顺序存储: **邻接矩阵** 是表示图中顶点之间相邻关系的矩阵. 矩阵中对于 `a[i][j]`, 如果其值为 1 则顶点 i, j 有边相连, 为 0 则没有边.
- 无向图的邻接矩阵是按主对角线对称的
- 有向图可用两个邻接矩阵, 一个表示出边, 一个表示入边
- 带权图中只要把 1 换成权值, 0 换成无穷大即可.
通常还需要使用一个一维数组存储顶点信息.

@see ALGraph.c

链式存储: 类似树中的孩子链表法, 把所有邻接于顶点 v 的顶点链成一个单链表, 这个单链表称为 顶点 v 的 **邻接表**. 为每个邻接表增设表头结点, 并使用一个以为数组存储起来, 这个数组就构成了图的邻接表表示.

## 图的遍历

遍历图是求解图的连通性, 图的拓扑顺序等算法的基础.


**深度优先搜索 (Depth First Search, DFS)** 类似于树的前序 (先根) 遍历. 按此得到的顶点序列称为图的 **DFS 序列**.

首先任选一个初始出发点 v, 并将其标记为已访问; 然后依次从 v 出发搜索每个邻接点 w, 若 w 未曾访问, 则以 w 作为新的出发点, 继续深度优先遍历. 直到图中所有和 v 有路径相通的顶点都被访问到; 若此时图中仍有顶点未被访问, 则另选一个未曾访问的顶点作为起点, 重复上述过程.

也可在找不到未被访问过的邻接顶点时, 回退到访问过的但上有未访问过邻接点的顶点, 从该顶点出发重复前面步骤.
此时可用一个栈保存被访问过的结点, 以便回溯查找被访问过结点的未被访问过的邻接点.

**广度优先搜索 (Breadth First Search, BFS)** 类似于树的按层次遍历. 按此得到的顶点序列称为图的 **BFS 序列**.

首先访问出发点 v, 接着依次访问 v 的所有未被访问过的邻接点 v1, v2, ... vn, 并均标记为已访问, 然后再按照 v1, v2, ..., vn 的次序, 访问每个顶点的所有未曾访问过的顶点并均标记为已访问, 以此类推, 直到所有和 v 有路径相通的顶点都被访问过.

因为先被访问的顶点, 其邻接点也先被访问, 符合队列先进先出特性. 实现时可使用一个队列, 依次记住被访问过的顶点.

DFS 和 BFS 遍历过程中, 为了避免顶点的重复访问, 设一个布尔数组 visited[0..n-1].

## 生成树和最小生成树

在图论中, 常常将树定义为一个无回路的连通图.
一个图的 **极小连通子图** 恰为一个无回路的连通图. 即若添加一条边就会出现回路, 若去掉一条边就成为非连通图.

**生成树** 是连通图中的包含图中所有顶点的一个极小连通子图 (边最少). 具有 n 个顶点的生成树有且仅有 n-1 条边, 但又 n-1 条边的图不一定是生成树.

因为 DFS 和 BFS 对图中的 n 个顶点都仅访问一次, 对其余 n-1 个顶点的访问一共要经过 n-1 条边, 这 n-1 条边将 n 个顶点连接成包含图中所有顶点的极小连通图, 即得到一个最小生成树. 其源点就是生成树的根. 并分别称为 DFS 生成树和 BFS 生成树.

一个图可有不同的生成树. 对于带权图, 把权值最小的生成树称为 **最小生成树 (Minimum Spanning Tree, MST).

构造 MST 的算法, 多数利用了如下的 **MST 性质**:
> 假设 N=(V, {E}) 是一个连通网, U 是顶点集 V 的一个非空子集, 若 (u, v) 是一条具有最小权值的边, 其中 u ∈ U, v ∈ V-U, 则必存在一颗包含边 (u, v) 的 MST.

Prim 算法: 不断增大与 MST 中已有顶点相邻且代价最小的边
> 假设 G=(V, E) 是一个具有 n 个顶点的连通网, T=(U, TE) 是 G 的 MST, 其中 U 是 T 的顶点集, TE 是 T 的边集, U 和 TE 初值均为空. 首先从 V 中任取一个顶点 v1, 将它并入 U 中, 此时 U={v1}. 然后只要 U 是 V 的真子集, 就从那些一个端点已在 T 中, 另一个端点仍在 T 外的所有边中, 找一条最短 (权值最小) 边, 假定为 (vi, vj), 其中 vi ∈ U, vj ∈ V-U, 并把该边和顶点 vj 分别并入 TE 和 U, 如此进行下去, 直到 n-1 次后把所有顶点都并入到 T 的顶点集 U 中.

Kruskal 算法: 不断合并边
> 假设 G=(V, E) 是一个有 n 个顶点的连通网, T=(U, TE) 是 G 的 MST, U 的初值等于 V, T 的初始状态是只含有 n 个顶点而无边的森林 T=(V, ∅). 将 G 中的边按权值从小到大依次选取 E 中的边, 若选取的边使 T 不形成环路, 则并入 TE; 若形成环路, 则舍弃. 如此进行直到 TE 中包含 n-1 条边为止.
> 由于一个网中会有权值相同的边, 从不同点出发可以得到不同的 MST

## 最短路径

从一个顶点到另一个顶点路径中, 所经边的权值之和最小的路径即 **最短路径**.

**单源最短路径问题**: 求从源点到图中其余各顶点的最短路径. **多源最短路径问题** 可用每个顶点作为源点调用一次单源最短路径问题算法求解.

Dijkstra 算法: 按路径长度递增顺序产生各顶点的最短路径:
> 设有向图 G=(V, E), 其中 V={1, 2, ..., n}. cost 表示 G 的邻接矩阵, cost[i][j] 表示有向边 <i, j> 的权. 若不存在有向边 <i, j>, 则 cost[i][j] 的权为无穷大. 设 S 是一个集合, 其中每个元素表示一个顶点, 从源点到这些顶点的最短距离已经求出. 设 v1 为 源点, S 初始只包含 v1. 数组 dist 记录从源点到其他各顶点当前的最短距离, 其初值为 dist[i]=cost[v1][i], i=2, ..., n. 从 S 之外的顶点集合 V-S 中选出一个顶点 w, 使 dist[w] 的值最小. 从源点到达 w 只通过 S 中的顶点, 把 w 加入集合 S 并调整 dist 中记录的距离, 即从原来的 dist[v] 和 dist[w]+cost[w][v] 中选出较小值作为新的 dist[v]. 重复上述过程, 直到 S 中包含 V 中其余顶点的最短路径.

> 算法的最终结果为:
> - S 记录了从源点到该顶点存在最短路径的顶点集合
> - dist 记录了从源点到 V 中各顶点之间的最短路径长度
> - path 是最短路径的路径数组, 其中 path[i] 表示从源点到顶点 i 的最短路径上顶点的前驱顶点

## 拓扑排序

把顶点表示活动, 边表示活动先后关系的有向无环图 (DAG) 称为顶点活动图 (AOV 网). 所有的活动排成一个线性序列, 使得每个活动的所有前趋活动都排在该活动前面, 次序列就是 **拓扑序列**. 求次序列的过程称为 **拓扑排序**.

拓扑排序:
1. 在图中选取一个没有前趋 (入度为零) 的顶点, 输出它
2. 从图中删除该顶点及与该顶点有关的所有边
3. 重复上述过程, 直到全部顶点都已输出, 或剩余顶点中没有入度为零的顶点为止
4. 输出剩余顶点

对给定的 AOV 网, 应首先判定网中是否存在环. 检测的方法是对有向图构造其顶点的拓扑序列, 若网中所有顶点都在它的拓扑序列中, 则该 AOV 网必定不存在环.

# 排序

**排序** 指整理文件中的记录, 使得按给定关键字递增或递减的次序排列. 如果存在多个相同关键字的记录, 排序之后这些记录之间的相对次序不变, 则称这种排序方法是 **稳定** 的; 反之则为 **不稳定** 的.
若整个待排序数组都在内存中处理, 不涉及数据的内外村交换, 成这种排序方法为 **内部排序**; 反之则为 **外排序**.

@?: 稳定与否似乎与是否存在不相邻记录之间的交换有关?

本书仅讨论内排序, 且假定关键字为整数, 按递增顺序排序.

评价排序算法的标准包括时间开销和空间开销以及算法本身的复杂度. 时间开销一般通过排序过程中关键字的比较次数和记录移动次数衡量.
若空间开销相对于数据量来说是一个常数, 则称排序方法为 **就地排序**.

## 插入排序

基本思想: 每次将一个记录插入到前面已排好序的文件中的适当位置.

直接插入排序:
1. 待排序记录被划分为有序区和无序区. 有序区最开始只包含第一个记录, 其余为无序区.
2. 每次从无序区取第一个元素, 插入到有序区适当位置
3. n-1 插入后, 无序区为空, 排序完毕

希尔排序 (缩小增量排序)
1. 分组: 取定一个小于记录数的整数 d 作为第一个增量, 把全部记录分成 d 个组, 所有下标距离为 d 的倍数的记录为一组
2. 排序: 在各组内进行直接插入排序. 然后再取一个小于 d 的整数作为第二个增量
3. 重复上述步骤, 直到增量为 1

## 交换排序

基本思想: 两两比较记录, 发现次序相反则交换.

冒泡排序: 使较小者从底部逐渐移向顶部.
1. 从最后位置到第一个位置, 依次进行相邻位置的两两比较, 若次序相反就交换. 第一趟排序结束, 此时第一个元素为最小.
2. 从最后位置到第二个位置, 依次进行相邻位置的两两比较, 若次序相反就交换. 第二趟排序结束, 此时第二个元素为次小.
3. 以此类推...

双向冒泡排序: 交替改变扫描方向
1. 第一趟从下往上扫描, 小者上浮到第一个位置.
2. 第二趟从第二个位置往下扫描, 大者下沉到最后一个位置.
3. 以此类推...

快速排序 (划分交换排序): 改进冒泡排序, 从两端向中间进行, 记录每次移动距离从相邻位置变为移到较远位置.
1. 设两个指针 i 和 j, 初值分别为 low 和 high. 设基准记录 x=R[i].
2. 从 j 位置向前扫描找到第一个关键字小于 x 的记录存入当前 i 位置, i 自增 1.
3. 从 i 位置向后扫描找到第一个关键字大于 x 的记录存入当前 j 位置, j 自减 1.
4. 重复上两步, 直到 i 等于 j. 此时 x 排到了适当位置, x 前所有记录为较小, x 后所有记录为较大.
5. 上述步骤称为一次划分. 递归进行划分, 直到所有记录排到适当位置.

## 选择排序

基本思想: 每趟在待排序记录中选出关键字最小的记录, 一次放到已排好序的记录序列的最后.

直接选择排序: 每次在无序区选出最小记录, 与无序区中第一个记录交换
1. 第一趟排序: 在所有记录中找出最小记录, 与第一个记录交换
2. 第二趟排序: 在剩下 n-1 个记录中找出最小记录, 与第二个记录交换
3. 以此类推, 进行 n-1 趟

## 堆排序

堆排序是对直接选择排序的改进:
    可以看出, 直接选择排序的每趟排序中, 有许多比较可能在前一趟排序已经做过, 但是当时没有将结果保存下来.
    堆排序则利用树形排序克服这一点.

堆排序是一种树形选择排序.

基本思想: 把记录数组看成一颗完全二叉树的顺序存储结构, 利用双亲和孩子结点内在关系, 在无序区选择最大(小)记录.

堆: 对于一颗完全二叉树中:
- 每个结点都比它的孩子结点大, 即为大跟堆
- 每个结点都比它的孩子结点小, 即为小根堆

堆排序正是利用大根堆 (或小根堆) 来选取当前无序区中最大 (或最小) 记录实现排序的.
1. 将当前无序区调整为一个大根堆
2. 将最大的堆顶记录和无序区最后一个记录
3. 重复上述建堆, 交换过程

可以看出
- 为了完成从小到大排序, 选择排序通过选取最小记录, 而堆排序通过选取最大记录进行交换, 刚好相反.
- 堆排序就是一个不断建堆的过程

建(大根)堆过程: 筛选法. 较小记录逐层筛下去, 较大记录逐层选上来
    将记录数组看成一颗完全二叉树顺序存储结构. 则任意节点 i 的左孩子为 2i, 右孩子为 2i+1, 双亲为 i/2.
    假如某一结点的左子树和右子树已经是堆, 只需将它两个孩子中较大者与它比较.
    如果它较小, 则交换, 这样可能破坏下一级的堆, 于是继续用上述方法构造下一级的堆.

## 归并排序

基本思想: 反复将两个有序的子文件两两归并, 得到更大的有序子文件.

二路归并排序:
1. 将待排序文件看成 n 个长度为 1 的有序子文件, 将这些子文件两两归并. 得到 n/2 个长度为 2 的有序子文件.
2. 将这 n/2 个子文件两两归并. 得到 n/4 个长度为 4 的有序子文件.
3. 如此反复.
4. 归并过程中

## 分配排序

前面所述排序算法都基于关键字的比较. 理论上已经证明, 基于比较的排序, 至少需要 nlogn 次比较.
有不需要比较的排序方法, 可使时间复杂度降为一线性阶 O(n). 分配排序即一种不基于比较的排序算法.

箱排序: 依次扫描并根据关键字对应的位置装箱, 然后连到一起.

抽象算法描述如下:

```c
// 设关键字取值范围是 0..m-1
// 设 B[0..m-1] 是一个记录数组, 它的每一个分量都是一个链队列, 代表一个箱子.
// B[i].f 和 B[i].e 分别表示该队列的头指针和尾指针
void BinSort(SeqList R, int n) {
    // 置空所有链队列
    for (i = 0; i < m; i++) {
        InitQueue(B[i]);
    }
    // 分配, 装箱
    for (i = 0; i < n; i++) {
        k = R[i].key;
        EnQueue(B[k], R[i]);
    }
    i = 0;
    while (Empty(B[i])) { // 找到第一个非空箱子
        i++;
    }
    p = B[i].f;           // p 指向排序后的第一个记录
    for (j = i+1; j < m; j++) {
        if (! Empty(B[i])) {
            // 将所指向记录链接到上一个非空箱子的尾指针所指向的结点之后
        }
    }
}
```

基数排序: 对关键字分解, 对分量进行多趟箱排序
1. 假如要排序文件为: {36, 25, 48, 10, 6}
2. 对记录进行分解, 可知每个位数取值范围为 0..9, 只需设置 10 个箱子. 即 **基数** 为 10.
3. 先对个位数进行箱排序, 得到 [10], [25], [36, 6], [48]
3. 再对十位数进行箱排序, 得到 [6], [10], [25], [36], [48]

它是对箱排序的改进和推广, 解决了箱排序的空间浪费问题.

# 查找

**查找** 又称检索. 当问题所涉及的数据量很大时, 查找效率就格外重要. 整个查找过程都在内存中进行即 **内查找**, 反之, 称为 **外查找**.

查找的主要操作是关键字的比较, 因此通常把平均比较次数 (也称为平均查找长度) 作为衡量效率的标准.

## 顺序表的查找

本章假定顺序表采用以为数组来表示.

顺序查找又称线性查找:
1. 从开始元素顺序扫描顺序表, 比较每个记录的关键字和查找值 k. 若等于 k, 则查找成功, 返回该记录的下标.
2. 直到所有记录都比较完, 仍未找到与 k 相等的记录, 则查找失败

二分查找又称折半查找, 要求线性表必须有序 (设为递增):
1. 将查找值和有序表中间位置的记录关键字比较
2. 若相等则查找成功
3. 若小于中间记录, 继续在左子表中进行二分查找
4. 若大于中间记录, 继续在右子表中进行二分查找

索引顺序查找又称分块查找, 要求表是 "分块有序" 的, 是介于顺序查找和二分查找之间的查找方法.
1. 分块有序: 将表 R[1..n] 均分为 b 块, 每块各 n/b 个结点 (最后一块可能不足). 每块中的结点不一定有序, 但前一块中的最大关键字必须小于后一块的最小关键字.
2. 构建索引表 ID[1..b], ID[i] 中存放着第 i 块的最大关键字及该块在 R 中的起始位置. 显然 ID 是按关键字递增有序的
3. 先在索引表中利用二分或顺序查找, 确定块
4. 然后在块中进行顺序查找

## 树表的查找

**二叉排序树 (Binary Sort Tree, BST)** 又称二叉查找树, 它具有下列性质:
1. 若它的右子树非空, 则右子树上所有结点的值均大于根结点的值
2. 若它的左子树非空, 则左子树上所有结点的值均小于根结点的值
3. 左, 右子树本身又各是一颗二叉排序树
4. 由上面三个性质可推出, 它的中序遍历序列是一个递增有序序列

插入:
若 BST 为空, 则把新结点作为根结点插入到空树
若 BST 非空, 比较新结点和根结点
    相等, 说明已经有此结点, 无需插入
    新结点较小, 插入到左子树
    新结点较大, 插入到右子树
在子树中插入过程同上, 如此进行下去

查找: 将 BST 看成有序表, 与二分查找类似
若 BST 为空, 查找失败
若待查找关键字等于根结点的关键字, 查找成功
若待查找关键字小于根结点的关键字, 继续在根结点的左子树查找
若待查找关键字大于根结点的关键字, 继续在根结点的右子树查找

删除: 假设删除结点 p, 删除之后仍要满足 BST 性质
1. 若 p 是叶子结点, 则直接删除
2. 若 p 只有一颗子树, 直接用 p 的子树取代 p
3. 若 p 既有左子树又有右子树, 任选以下方式之一处理
    - 用 p 的直接前趋结点 (左子树中最大的结点, 位于左子树中最右边且没有右子树) 代替 p
    - 用 p 的直接后继结点 (右子树中最小的结点, 位于右子树中最左边且没有左子树) 代替 p

BST 的算法性能取决于其深度, 所以有很多动态平衡的方法, 使的向树中插入或删除结点时, 通过调整树的形态来保持树的平衡, 使其既满足 BST 的性质, 又保证树的深度始终是 O(logn), 这种 BST 就是所谓的 **平衡二叉树**.

## B 树

**B 树** 是一种平衡的多路查找树, 它在文件系统中非常有用.

一颗 m(m>=3) 阶的 B 树或为空树, 或为满足以下性质的 m 叉树:
每个结点至少包含下列信息域: (n, p0, k1, p1, k2, ..., kn, pn)
    n 为关键字的个数
    k 为关键字
    p 为指向子树根结点的指针, 且 p 所指向的子树中所有结点均大于其前邻的 k, 小于其后临的 k
    注意, p 的个数总是比 k 的个数多 1
每个结点至多有 m 棵子树
若树非空, 则根结点至少有 1 个关键字, 至多有 m-1 个关键字
所有的叶子结点都在同一层次上, 并且不带信息 (可看做外部结点或查找失败的结点)
除根之外的所有非终端节点所包含的关键字个数满足: ⌈m/2⌉-1 ≤ n ≤ m-1, 故至少有 ⌈m/2⌉ 棵子树, 至多有 m 棵子树.

插入:
先在最底层的某个非终端结点中添加一个关键字
若结点中关键字个数仍不超过 m-1, 插入完成
否则要产生结点 "分裂"
    把结点分成两个, 将中间的一个关键字拿出来插入到该结点的双亲结点
    如果双亲结点已有 m-1 个关键字, 则导致双亲结点继续分裂
    这一过程可能波及 B 树的根结点, 引起根结点的分裂, 从而使 B 树张高一层

删除:
1. 首先找到要删除的关键字所在的结点
2. 若该结点不在含有信息的最后一层, 则将该关键字用其后继关键字替代, 然后再删除其后继关键字信息.
   因此, 最终始终是要删除一个最下层结点中的关键字, 此时:
    - 若结点中关键字数目不小于 ⌈m/2⌉, 只需删除关键字和响应指针即可.
    - 若结点中关键字数目等于 ⌈m/2⌉-1, 即数目已经是最小值, 直接删除会破坏性质:
        - 若结点左 (或右) 邻兄弟结点关键字数目不小于 ⌈m/2⌉
            1. 将其兄弟结点中最大 (最小) 关键字上移至双亲结点
            2. 将双亲结点中相应的关键字移至被删关键字所在结点中
        - 若结点相邻左右兄弟结点中关键字数目都等于 ⌈m/2⌉-1:
            1. 需将被删结点与某个兄弟结点 "合并"
            2. 这一过程可能波及根, 引起对根结点中关键字的删除, 从而可能是 B 树高度降低一层

查找: 类似 BST, 但需要经过与多个关键字比较厚才能处理完一个结点, 故称 B 树为 **多路查找树**
1. 设查找给定值 K, 将每个结点的 key[0] 作为哨兵存储 K 值
2. 若 B 树非空, 则先取出树根结点, 将 K 一次从右向左与根结点中每个关键字比较, 直到找到一个小于等于 K 的关键字, 此时:
    - 若找到的关键字与 K 相等, 且不是 key[0], 则表明查找成功
    - 否则, 继续在所找到的关键字对应的子树中继续查找即可

@see BTree.c

**B+ 树** 是一种常用语文件组织的 B 树的变形. 一颗 m 阶的 B+ 树与 B 树的区别在于:
- 有 k 个孩子的结点中含有 k 个关键字.
- 所有叶子结点中包含了全部关键字的信息, 及指向含有这些关键字记录的指针, 且叶子结点本身依照关键字从小到大顺序链接.
- 所有非终端结点可看成索引部分, 结点中仅含有其子树 (根结点) 中的最大 (或最小) 关键字.

因此, 可以对 B+ 树进行两种查找运算
- 一种是从最小关键字其进行顺序查找
- 另一种是从根结点开始进行随机查找

@todo image

## 散列表查找

**散列存储** 的基本思想: 以线性表中每个元素的关键字为自变量, 通过一种函数 H(key) 计算出函数值, 把这个函数值解释为连续存储空间的单元地址, 将该元素存储到这个单元中.
- 其中使用的函数称为 **散列(哈希)函数**, 它实现关键字到存储地址的映射.
- 得到的函数值称为 **散列(哈希)地址**.
- 使用的数组空间是线性表进行散列存储的地址空间, 称为 **散列(哈希)表**.

多个元素经过散列函数计算, 可能得到相同的散列地址, 这种现象称为 **散列(哈希)冲突**. 具有相同散列地址的关键字称为 **同义词**. 冲突的频度与下列因素相关:
- 设计不良的散列函数. 因此设计散列函数时, 要考虑避免或尽量减少冲突.
- 散列表中已占用的单元数和散列表表长之比, 称为 **装填因子**. 装填因子越大, 冲突机会越大.

常用的散列函数有:
- 直接地址法: H(key) = key + C. 适合关键字分布基本连续的情况, 否则空号较多, 造成空间浪费.
- 数字分析法: 假设每个关键字由多位数字组成, 提取数字分布比较均匀的若干位作为散列地址.
- 除余数法: H(key) = k % p. 其中 p 最好选取小于或等于表长的最大素数.
- 平方取中法: 取关键字平方的中间几位作为散列地址. 因为乘积的中间几位和乘数的每一位都相关, 故散列地址较均匀.
折叠法: 将关键字分割成位数相同的几段, 段的位数等于散列地址的位数, 然后所有段的叠加和为散列地址.

---

冲突一般不可避免, 因此需要处理冲突:

开放定址法: 根据探查序列逐个单元查找, 直到找到空闲单元. 设初始探查地址为 d:
- 线性探查法: 将散列表看成循环向量, 依次探查, 直到循环到初始探查单元的前一单元.
- 二次探查法: 探查序列为: d+1^2, d-1^2, d+2^2, d-2^2, ...
- 双重散列法: d, (d+1*h(key))%m, (d+2*h(key))%m, ... 其中 h 是不同于 H 的散列函数.

拉链法: 每个地址都有对应的一条链表, 把同义词放到同一单链表中.

---

性能:
仍然有一个与关键字比较的过程, 但是比顺序查找小得多, 比二分查找也小.
平均查找长度不是结点数的函数, 而是装填因子的函数.
只要装填因子选择合适, 平均查找长度就是一个常数.
