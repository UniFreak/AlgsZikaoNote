# 概论

NOTE:
- i 从 1 开始...
- 命名: ListSize -> listSize
- 注释: p.
- 书中错误: @err
- main 简单的用例测试
- dump
- *Test.c

TODO:
- test.sh: test.sh *, test LinkStack...

Learn:
- malloc, 指针, NULL 对于初始化的作用

## 数据结构

好的算法必须建立在研究数据的特性及数据之间存在的关系的基础之上.

**数据结构**一般包括三方面内容
- 数据之间的逻辑 (或抽象) 关系, 即**逻辑结构**. 包括*
    + **线性结构** (如线性表, 栈, 队列)
    + **非线性结构** (如树, 图)
- 数据元素及其关系在计算机内的存储方式, 即**存储结构(物理结构)**
    + **顺序存储**: 逻辑上相邻的点在物理位置上也相邻. 通常用于线性结构数据, 但非线性结构也可以通过线性化方法用顺序存储
    + **链接存储**: 元素间的关系用附加的指针域表示, 物理位置不一定连续
    + **索引存储**: 存储元素的通史, 附加建立一份索引表
    + **散列存储**: 根据元素关键字直接计算出元素的存储地址
- 数据的**运算**, 如增删改查等

    运算的具体实现是在存储结构上进行的, 因此在逻辑结构上定义的运算, 只要给出运算的功能是 "做什么", 至于 "怎么做" 等实现细节, 只有待确定了存储结构之后才能考虑

    对于不同问题, 需要的运算可能不同.

    复杂的运算, 可用基本运算的组合来实现.


数据结构 VS 数据类型 VS 抽象数据类型 (ADT)
- 数据类型可看作是程序设计语言中已实现的数据结构
- 抽象数据类型可看做是描述问题的模型, 它独立于具体实现. 等价于在数据的逻辑结构以及在逻辑结构上定义的抽象操作

## 算法

**算法**是对问题求解步骤的描述. 必须满足以下**五个准则**:
1. 给定输入
2. 至少有一个或多个输出
3. 有穷: 每个步骤的执行次数必须有限, 且在又穷时间内完成
4. 确定: 每个步骤的含义明确无二义
5. 可行: 每个步骤都可以通过有限次的基本运算来实现

算法不依赖于计算机程序语言, 可用自然语言, 程序语言, 约定的符号语言等描述.

对算法的评价和**分析**包括:
- 最主要的是**时间复杂性**, 即算法耗费的时间
- **空间复杂性**, 即算法耗费的存储空间
- 可读性和可操作性

# 线性表

定义: 由 n 个数据元素组成的有限序列. 数据元素的个数 n 为表的长度. 当 n 为 0 时称为空表.

逻辑特征
- 有且仅有一个开始元素, 它没有前趋, 仅有一个直接后继
- 有且仅有一个终端元素, 它没有后继, 仅有一个直接前趋
- 其余元素称为内部元素, 它们都有且仅有一个直接前趋和一个直接后继
- 这种相邻关系又称为线性关系, 可见线性表是一种典型的线性结构


## 顺序存储

使用顺序存储的线性表称为**顺序表**. 它的特点是:
- 只要知道基地址和每个元素占用的单元数, 就可求出任一元素的地址
- 任意元素都可随机存取 (存取某个位置的元素不必事先存取其前一个元素), 顺序表是一种随机存取结构

缺点: 需要移动大量元素 -> 链式存储

通常用数组来描述顺序表

基本运算: @see SeqList.c

## 链式存储

缺点:
链表的结点不可以随机存取

链式存储不仅可以用来表示线性表, 还可以用来表示各种非线性的数据结构.

### 单链表

链表: 元素由两部分组成:
数据域: 存储数据元素
指针域: 存储直接后继地址

用这种存储方式表示的线性表称为链表. 每个结点只包含一个指针域, 因此又称为单链表.
终端结点的指针域为空, 即 NULL
设立头指针指向开始结点.
如果链表中一个结点都没有, 则为空链表. 此时头指针为 NULL

一个单链表可由头指针唯一确定, 因此单链表可以用头指针的名字来命名.
为方便操作, 可以在开始结点之前附加一个头结点.

存取第 i 个结点时, 必须从表头结点开始搜索, 所以链表结构是非随机存取存储结构. 若链表带头结点时, 就应特别注意头结点和表头结点 (即开始结点) 的区别.

基本运算: @see LinkList.c

### 循环链表

**循环链表**是链式存储的另一种形式, 它的特点
- 单链表中最后一个结点的指针域不为空, 而是指向链表的头结点, 是整个链表构成一个环
- 从表中任一结点开始都可以访问表中的其他结点

可有单循环链表, 还可以有多重链的循环链表

它的结点类型与单链表完全相同, 在操作上也与单链表基本一致, 差别仅在于算法中循环结束判断条件不再是 p 或 p->next 是否为空, 而是他们是否等于头指针.


@see CycleLinkList.c

### 双向链表

向单向链表的结点类型中, 增加一个指向其直接前趋的指针域, 这样形成的链表为**双向链表**.

双向链表可以从表中快速确定一个结点的直接前趋.

@see DLinkList.c

双链表中增设一个头结点, 将尾结点和头结点链接起来就构成了**双向循环链表**

# 栈和队列

## 栈

**栈**是一种限定在表的一端进行插入和删除运算的线性表. 将插入, 删除的一端称为栈顶, 另一端称为栈底. 栈又称为后进先出 (LIFO) 表. 插入称为**进栈**, 删除称为**退栈**.

栈的顺序存储结构称为**顺序栈**, 类似于顺序表, 顺序栈也使用数组实现. 一般将栈底设置在数组最低端 (下标 0), 并设置栈顶指针指示栈顶位置.

当栈满时, 进栈会导致**上溢**; 当栈空时, 退栈会导致**下溢**.

@see SeqStack.c

如果将多个栈分配在同一个顺序存储空间内, 则可以相互进行调节, 即节约空间, 又可降低发生溢出的概率. 可以将两个栈的栈底分别设在顺序存储空间的两端, 让两个栈各自向中间延伸.

---

栈的链式存储结构称为**链栈**, 它是运算受限的单链表. 不必设置头结点. 可以克服顺序栈的溢出和空间浪费问题.

---

栈的应用非常广泛, 只要问题满足 LIFO 原则, 都可使用栈作为数据结构, 如
- 圆括号匹配的检验 @see SeqStack.c:Expr
- 字符串回文的判断 @see SeqStack.c:symmetry
- 数值转换 @see SeqStack.c:conversion
- 通过递归工作栈, 实现递归
- 实现程序设计语言的函数调用和返回

## 队列

**队列**也是一种操作受限的线性表, 它只允许在表的一端进行插入, 而在另一端进行删除. 插入的一端称为**队尾**, 删除的一端称为**队头**. 元素的插入称为**入队**, 删除称为**出队**. 又称队列为**先进先出 (FIFO) 表**.

队列的顺序存储结构称为**顺序队列**. 需要设置队头指针 front 和队尾指针 rear. 它们的初值为 0.
入队时, 将元素插入队尾指针所指位置, 并将队尾指针加 1.
出队时, 将队头指针加 1, 并返回被删除的元素.
头尾指针相等时队列为空.

@see SeqQueue.c

如果用数组实现顺序队列, 当队尾指针指向数组最后一个元素时, 继续插入新元素, 则会发生上溢, 而出队的位置又无法再利用. 为了克服这两个问题, 可将数组想象为一个环状空间, 称这种环状数组表示的队列为**循环队列**.
- 可用求余运算, 判断发生上溢时, 进入下一个循环.
- 队列无论是空是满, 都有 队头指针 == 队尾指针.

    为了判断队列是空是满, 有几种常用方法:
    - 另设一个标志位, 标记队列是空是满
    - 设置计数器记录队列中元素个数
    - 少用一个元素空间, 即 rear 所指向的单元始终为空. 约定入队前, 测试 rear + 1 是否等于头指针. 是则队满.

@see CirQueue.c

---

队列的链式存储结构称为**链队列**.
需增设一个尾指针以方便在表尾做插入操作.
于是一个链队列就由一个头指针和一个尾指针唯一确定.
为了简化边界条件的处理, 队头结点之前也附加一个头结点, 并设头指针指向此结点.

@todo 图

@see LinkQueue.c

---

用一个带头结点的循环单链表表示队列, 成为**循环链队列**.

该队列只设一个队尾结点指针 rear, 不设头指针. 且 rear->next 回指到头结点.

@see CirLinkQueue.c

---

栈和队列的应用实例: 中缀表达式的计算

我们平时写的计算式如 8+5*(7-3), 因为运算符放到操作数中间, 称为**中缀表达式** (逆波兰表示法). 为了方便计算机处理, 可以把运算符放到操作数后面, 即**后缀表达式**. 如 8 5 7 3 - * +. 要计算该表达式, 可以从左向右扫描, 直到遇到一个运算符后即开始运算. 遇到 -, 计算 7-3, 得到 4, 原计算式变为 854*+; 遇见 *, 计算 5*4=20, 计算式变为 8 20 +; 遇见 +, 计算 8 + 20 = 28. 得到了最终结果. 后缀表达式的这种计算规则, 正是运用栈和队列的典型例子.

- 先通过栈将中缀表达式变为后缀表达式:

    从例子中可以看到, 将中缀表达式变为后缀表达式时, 运算符依据优先级从高到低从左向右的排列. 转换过程如下:
    1. 顺序扫描中缀表达式, 遇到数字时, 将其送至输出队列中
    2. 遇到运算符时, 将栈中所有优先级高于或等于该运算符的运算符弹出, 送至输出队列, 再将当前运算符入栈
    3. 遇到左括号时, 入栈
    4. 遇到右括号时, 将靠近栈顶的第一个左括号上面的运算符全部依次弹出, 送至输出队列中, 再删除栈中的左括号

- 然后计算后缀表达式

    因为运算符已经按照优先级顺序排好, 所以很容易用计算机实现. 因为计算后缀表达式时, 最后保存的值最先取出参与运算, 所以需要栈保存中间结果.

@see PostExp.c

# 多维数组和广义表

## 多维数组

当数组维数为 1 时, 它是一种元素个数固定的线性表. 当是多维数组时, 它可以看成是线性表的推广. 以二维数组为例:

    a1 a2 a3 a4
    b1 b2 b3 b4
    c1 c2 c3 c4

- 除了边界元素外, 每个元素都有分别位于行向量上和列向量上的两个直接前趋和两个直接后继. 如 b2 的两个直接前趋为 b1 和 a2, 两个直接后继为 b3 和 c2
- 开始结点 (a1) 没有前趋, 终端结点 (c4) 没有后继
- 边界上的结点只有行或列上的一个直接前趋或一个直接后继. 如 b1 只有一个前趋结点 a1, b4 只有一个后继结点 c4

@see Array.c

## 矩阵的压缩存储

矩阵一般用数组来存储.

**特殊矩阵**指的是相同值的元素或者零元素在矩阵的分布有一定规律的矩阵. 可以对这类矩阵采取压缩存储.

---

**对称矩阵**: 元素关于主对角线对称分布. 则只需要存储矩阵上三角或下三角元素. 如下面的矩阵

    00
    10  11
    20  21  22
    ...

假设行数为 n, 可以看出, 如果把上面的矩阵存储到一维数组中, 则总共需要 n(n+1)/2 个空间.

而且矩阵中元素 ij 对应到以为数组位置 k 有如下关系:
- 如果 i>=j, 则 ij 位于下三角: `k = i * (i + 1) / 2 + j`
- 如果 i<j,  则 ij 位于上三角: `k = j * (j + 1) / 2 + i`

@see SymMatrix.c

---

**三角矩阵**指矩阵的对角线上方或下方均为常数或零的方阵. 分别称为下三角矩阵或上三角矩阵.

比之对称矩阵, 需额外存储重复的元素. 故需要 n(n+1)/2+1 个空间.

对于上三角矩阵, 矩阵元素 ij 对应到数组位置 k 的关系为:
- 如果 i<=j, 则 ij 位于上三角: `k = i * (2n - i + 1) / 2 + j - i`
- 如果 i>j, 则存储于最后一项: `k = n (n + 1) / 2`

对于下三角矩阵, 矩阵元素 ij 对应到数组位置 k 的关系为:
- 如果 i>=j, 则 ij 位于下三角, 类似对称矩阵: `k = i * (i + 1) / 2 + j`
- 如果 i>j, 则存储于最后一项: `k = n (n + 1) / 2`

---

**稀疏矩阵**是非零元素的分布没有规律的矩阵, 因此在存储非零元素值时, 还需同时存储该元素的行列位置, 所以可用一个称为三元组 `(i, j, a[i][j])` 来唯一确定一个非零元素. 对稀疏矩阵的压缩存储通常有顺序存储和链式存储两种方法.
- 链式存储一般用十字链表法, 比较复杂, 不做介绍
- 顺序存储: 将三元组按行优先的顺序排列, 可得到一个其结点均为三元组的线性表, 称为**三元组表**


为了便于随机存取**任一行**的非零元素, 可以在三元组表表示的系数矩阵中额外存储每一行的第一个非零元素在三元组表中位置的数组. 这样的表示叫做**带行表的三元组表**, 又称为**行逻辑连接的顺序表**.


@see TSMatrix.c

## 广义表基础

**广义表**是线性表的推广, 又称列表. 线性表中的元素仅限于原子项, 如果放松这种限制, 允许它们自身具有结构, 就产生了广义表的概念. 广义表是 n 个元素的有限序列, 其中的元素或者是原子项, 或者是一个广义表. n 为它的长度, 内层的广义表称作**字表**. 嵌套的层数称为它的**深度**. 称第一个元素为表头, 称**其余元素组成的表**为**表尾**. 显然, 广义表是一个递归定义, 它是一种多层次的非线性结构. 它不仅是线性表的推广, 也是树结构的推广.

广义表通常记为 LS=(a1, a2, ..., an).

注意, () 和 (()) 是不同的. 前者是空表, 长度为 0, 后者是由空表做元素的广义表, 长度为 1.

通常采用链式存储结构表示广义表.

@see GList.c

# 树和二叉树

树形结构是一个递归结构. **树**是 n(n>=0) 个结点的有限集. 它是空集, 或者是非空集. 对于任意一棵非空树:
- 有且仅有一个特定的称为**根**的结点
- 当 n > 1 时, 其余结点可分为互不相交的有限集, 其中每个集合本身又是一棵树, 并称为根的**子树**

一般可以用以下几种表示法表示一棵树:
- 树形图表示法
- 嵌套集合的形式
- 凹形表示法
- 广义表形式

@todo 图

树的**结点**包含一个数据元素及若干个指向其子树的**分支**. 一个结点的子树数叫做结点的**度**. 最大的度称为该树的度. 度数为零的结点称为**叶子**结点或**终端**结点, 不为零的称为**非终端**结点或**分支结点**. 分支结点也叫内部节点, 而根结点又称为开始结点.

## 二叉树

**二叉树**的每个结点至多只有两颗子树. 并分别叫做根的左子树和右子树. 它可以是空集.

性质:
- 第 i 层至多有 2^(i-1) 个结点
- 深度为 k 的二叉树至多有 2^k-1 个结点. 把有 2^k-1 个结点的树叫做**满二叉树**
- 终端结点数等于度数为 2 的结点数再加 1
- 具有 n 个结点的完全二叉树的深度为 floor(logN) + 1 或 ceil(log(N+1))

**完全二叉树**只深度为 k 的二叉树, 前 k-1 层是一颗满二叉树, 而最下一层的结点都集中在最左边的若干位置.

对于具有 N 个结点的完全二叉树, 从树根开始自上到下自左到右的为每个结点编号, 则可以根据编号 i 可推导其父结点和子结点编号:
- 若 i=0, 则该结点为根结点, 无双亲. 若 i != 0, 则该结点的双亲编号为 floor((i-1)/2)
- 若 2i+1 < n, 则该结点的左孩子结点编号为 2i+1, 否则无左孩子, 即该结点必定是叶子结点
- 若 2i+2 < n, 则该结点的右孩子结点编号为 2i+2, 否则无右孩子

顺序存储结构
对于完全二叉树来说, 顺序存储结构既简单有节省存储空间. 而且对于插入和删除操作, 需要移动大量结点.
对于一般的二叉树, 必须增加一些虚结点使其成为完全二叉树, 这样的话会造成存储空间上的浪费.

链式存储结构
设计不同的结点可构成不同形式的链式存储结构. 通常是为每个结点设置三个域, 值域, 左指针域和右指针域. 有时为了便于查找结点双亲, 还可以增加一个指向双亲的指针.

称为**二叉链表**.

@see BinTree.c

遍历二叉树是二叉树中所有其他运算的基础. 所谓遍历, 指沿着某条搜索路径一次对树中每个节点访问, 且仅访问一次.
遍历一颗二叉树可分解为三步: 访问根结点 D, 遍历左子树 L, 和遍历右子树 R. 则有 DLR,  LDR, LRD 和 DRL, RDL, RLD 六种次序的遍历方案. 由于后三种和前三种对称, 仅讨论前三种.

DLR: 在访问子树前访问根结点, 称为**前序遍历**或**先根遍历**. 类似的
LDR: **中序遍历**
LRD: **后序遍历**

由二叉树的中序和前序遍历序列, 或者中序和后序遍历序列, 可唯一的确定一颗二叉树. 具体方法如下:
1. 根据前序或后续序列确定二叉树的各子树的根
2. 根据中序序列确定各子树根的左右子树

如前序序列为 abdeghcfi, 中序序列为 dbgehacif, 求二叉树:
1. 前序序列确定二叉树的根为 a, 再由中序序列确定 a 的左右子树
- a | bdegh | cfi     前序序列确定: 根, 左子树,右子树
- dbgeh | a | cif     中序序列确定: 左子树, 根, 右子树
2. 确定 a 的左子树
- b | d | egh         前序序列确定: 根, 左子树, 右子树
- d | b | geh         中序序列确定: 左子树, 根, 右子树
3. 再确定 b 的右子树: 唯一确定 e 为根, g 和 h 分别为左子树和右子树
- e | g | h           前序序列确定: 根, 左子树, 右子树
- g | e | h           中序序列确定: 左子树, 根, 右子树
4. 确定 a 的右子树
- c | fi              前序序列确定: 根, 右子树
- c | if              中序序列确定: 根, 右子树
5. 确定 c 的右子树
- f | i               前序序列确定: 根, 左子树
- i | f               中序序列确定: 左子树, 根

最终确定的树如下:

            a
          /   \
        b      c
      /  \       \
    d     e        f
         /  \     /
        g    h   i

## 线索二叉树

遍历二叉树以得到一个线性序列, 实质上是对一个非线性结构的**线性化操作**, 使得每个结点在序列中有且仅有一个直接前趋和一个直接后继.

使用二叉链表存储二叉树时, 因为每个结点之后指向左右子树的指针域, 不方便其前趋和后继结点的查找. 为了找到结点的直接前趋和后继, 可以在每个结点中增加前趋指针和后继指针域. 但这样会降低存储空间利用率.

另一方面. n 个结点的二叉链表中必定存在 n+1 个空指针域 (因为 n 个结点一共有 2n 个指针, 其中根结点不占用指针, 所以占用的指针为 n-1 个, 还剩 2n-(n-1)=n+1 个空指针域), 可以利用这些空指针域存放前趋和后继指针, 这些指针称为**线索**. 相应的二叉链表称为**线索链表**, 相应的二叉树称为**线索二叉树**. 而加线索的过程即**线索化**.

按照某种次序遍历二叉树, 遍历过程中用线索取代空指针即可实现线索化.

@see BinThrTree.c

## 树和森林

@see Tree.c

存储结构: @TODO image

双亲表示法: 树结构中每个结点的双亲是唯一的. 如果以一组连续空间 (数组) 存储树的结点, 同时为每个结点附加一个指向双亲的指针, 就可唯一的表示一棵树. 这种表示法方便查找双亲操作.

孩子链表法: 把每个结点的孩子结点看成一个线性表, 并以单链表结构存储其孩子结点. n 个结点就有 n 个孩子链表. 为了便于查找, 将树中各结点的孩子链表的头结点存放在一个指针数组中. 这种表示法方便查找孩子结点操作.

带双亲的孩子链表法: 将上述两种表示法结合起来, 既方便查找双亲, 也方便查找孩子.

孩子兄弟表示法: 又称二叉链表表示法. 即以二叉链表作为树的存储结构. 链表中两个链指针域分别指向该结点的第一个孩子结点和下一个兄弟结点. 这种方式的优点是, 它和二叉链表表示完全一样, 可利用二叉树的各种算法实现对树的操作.

---

给定一棵树, 可以找到唯一的一颗二叉树与之对应. 从物理结构上看它们是相同的, 只是解释不同而已.

将树转换为二叉树:
1. 首先在所有兄弟结点之间加一道线
2. 然后再对每个结点保留长子的连线, 去掉该结点与其他孩子的连线

将森林转换为二叉树:
1. 先将每一棵树转化成二叉树
2. 再将二叉树的根节点看作是兄弟连在一起, 形成一颗二叉树

将二叉树转换成树或森林:
1. 若结点 x 是双亲 y 的左孩子, 则把 x 的右孩子, 右孩子的右孩子... 都与 y 连起来
2. 去掉所有双亲到右孩子的连线

---

树的遍历

- 前序遍历

    先访问树的根结点, 然后依次前序遍历根的每颗子树.
    等价于前序遍历该树对应的二叉树

- 后序遍历

    限一次后序遍历根的每颗子树, 然后访问根结点
    等价于中序遍历该树对应的二叉树

森林的遍历

- 前序遍历

    从左到右依次按前序次序遍历森林中的每一棵树
    等价于前序遍历森林对应的二叉树

- 后序遍历

    从左到右依次按后序次序遍历森林中的每一棵树
    等价于中序遍历森林对应的二叉树

## 哈弗曼树

@see HuffmanTree.c

两个节点构成的路径上的边的数目称为**路径长度**. 树根到树中每个节点的路径长度称为**树的路径长度**.

为结点赋上具有某种意义的数, 称为该结点的**权**. 从树根结点到某结点之间的路径长度与该结点的权的乘积称为该结点的**带权路径长度**. 树中所有叶子结点的带权路径长度之和称为**树的带权路径长度**.

带权路径长度最小的二叉树称为**哈弗曼树**或**最优二叉树**.
一般利用哈夫曼树可以得到最佳的判定算法.

若叶结点上的权值均相同, 其中完全二叉树一定是最优二叉树, 否则不一定是最优二叉树.

利用哈夫曼算法可以构造最优二叉树. 步骤如下:
1. n 个带权值的相互孤立的叶子结点, 组成一个森林
2. 选出两个权值最小的结点, 作为左右子树, 构成一个新树. 置新树的根结点为左右子树的权值之和
3. 从森林中删除刚才选出的两个节点, 把新树加入到森林
4. 重复 2, 3. 直到森林中只剩下一棵树为止, 这棵树就是哈夫曼树

可见, n 个叶子结点需要合并 n-1 次, 产生 n-1 个新结点, 因此最终的哈弗曼树含有 2n-1 个结点.

---

对于 n 中字符, 根据其在报文中出现的频率, 作为其权, 然后构造一颗哈弗曼树. 把树中的做分支约定为 0, 右分支约定为 1, 取每条路径上的 0, 1 序列作为叶子结点对应字符的字符编码. 这就是**哈弗曼编码**.

哈夫曼编码也是一种**前缀编码**, 即保证任意字符的编码都不是另一个字符编码的前缀.

# 图

**图**是一种复杂的非线性结构. 在图形结构中, 结点之间的关系可以是任意的.

若图中每条边都是有方向的, 则该图为**有向图**. 连接两个结点的边则为**有向边**. 有向边又称为**弧**, 边的起点称为**弧尾**, 终点称为**弧头**.

若每条边都没有方向, 则该图为**无向图**.

边两端的结点互为**邻接点**, 或称它们彼此**相邻接**.

无向图边数的取值范围是 0~n(n-1)/2, 具有 n(n-1)/2 个边的无向图称为 **无向完全图**.
有向图边数的取值范围是 0~n(n-1), 具有 n(n-1) 个边的有向图称为 **有向完全图**.

顶点的**度**即以该顶点为端点的边的数目, 对于有向图, 分为**入度** (以顶点为终点的入边数目) 和**出度** (以顶点为起点的出边数目).

无论无向图还是有向图, 边数等于所有边的度数之和的一半.

如果沿着图中的边可从顶点 P 到顶点 Q, 则称存在一条**路径**, 且这两个顶点是 **连通** 的. 如果除了起点和终点可为同一个顶点外, 其余顶点均不相同, 称为 **简单路径**. 否则称路径为 **回路** 或 **环**.

如果无向图中任意两个顶点都连通, 称无向图为**连通图**. 无向图的极大连通子图称为 **连通分量**, 显然, 任何连通图的连通分量只有其自身. 而非连通图的无向图有多个连通分量.

如果有向图中任意两个顶点都连通, 则称有向图为 **强连通图**. 有向图中的极大连通子图称为 **强连通分量**.

若在边上标上具有某种意义 (距离, 时耗等) 的数值, 该数值称为该边的 **权**. 带权的图称为 **带权图**. 带权的连通图称为 **网络**.

## 存储结构

@see MGraph.c

顺序存储: **邻接矩阵** 是表示图中顶点之间相邻关系的矩阵. 矩阵中对于 `a[i][j]`, 如果其值为 1 则顶点 i, j 有边相连, 为 0 则没有边.
- 无向图的邻接矩阵是按主对角线对称的
- 有向图可用两个邻接矩阵, 一个表示出边, 一个表示入边
- 带权图中只要把 1 换成权值, 0 换成无穷大即可.
通常还需要使用一个一维数组存储顶点信息.

@see ALGraph.c

链式存储: 类似树中的孩子链表法, 把所有邻接于顶点 v 的顶点链成一个单链表, 这个单链表称为 顶点 v 的 **邻接表**. 为每个邻接表增设表头结点, 并使用一个以为数组存储起来, 这个数组就构成了图的邻接表表示.

## 图的遍历

遍历图是求解图的连通性, 图的拓扑顺序等算法的基础.


**深度优先搜索 (Depth First Search, DFS)** 类似于树的前序 (先根) 遍历. 按此得到的顶点序列称为图的 **DFS 序列**.

首先任选一个初始出发点 v, 并将其标记为已访问; 然后依次从 v 出发搜索每个邻接点 w, 若 w 未曾访问, 则以 w 作为新的出发点, 继续深度优先遍历. 直到图中所有和 v 有路径相通的顶点都被访问到; 若此时图中仍有顶点未被访问, 则另选一个未曾访问的顶点作为起点, 重复上述过程.

也可在找不到未被访问过的邻接顶点时, 回退到访问过的但上有未访问过邻接点的顶点, 从该顶点出发重复前面步骤.
此时可用一个栈保存被访问过的结点, 以便回溯查找被访问过结点的未被访问过的邻接点.

**广度优先搜索 (Breadth First Search, BFS)** 类似于树的按层次遍历. 按此得到的顶点序列称为图的 **BFS 序列**.

首先访问出发点 v, 接着依次访问 v 的所有未被访问过的邻接点 v1, v2, ... vn, 并均标记为已访问, 然后再按照 v1, v2, ..., vn 的次序, 访问每个顶点的所有未曾访问过的顶点并均标记为已访问, 以此类推, 直到所有和 v 有路径相通的顶点都被访问过.

因为先被访问的顶点, 其邻接点也先被访问, 符合队列先进先出特性. 实现时可使用一个队列, 依次记住被访问过的顶点.

DFS 和 BFS 遍历过程中, 为了避免顶点的重复访问, 设一个布尔数组 visited[0..n-1].

## 生成树和最小生成树

在图论中, 常常将树定义为一个无回路的连通图.
一个图的 **极小连通子图** 恰为一个无回路的连通图. 即若添加一条边就会出现回路, 若去掉一条边就成为非连通图.

**生成树** 是连通图中的包含图中所有顶点的一个极小连通子图 (边最少). 具有 n 个顶点的生成树有且仅有 n-1 条边, 但又 n-1 条边的图不一定是生成树.

因为 DFS 和 BFS 对图中的 n 个顶点都仅访问一次, 对其余 n-1 个顶点的访问一共要经过 n-1 条边, 这 n-1 条边将 n 个顶点连接成包含图中所有顶点的极小连通图, 即得到一个最小生成树. 其源点就是生成树的根. 并分别称为 DFS 生成树和 BFS 生成树.

一个图可有不同的生成树. 对于带权图, 把权值最小的生成树称为 **最小生成树 (Minimum Spanning Tree, MST).

构造 MST 的算法, 多数利用了如下的 **MST 性质**:
> 假设 N=(V, {E}) 是一个连通网, U 是顶点集 V 的一个非空子集, 若 (u, v) 是一条具有最小权值的边, 其中 u ∈ U, v ∈ V-U, 则必存在一颗包含边 (u, v) 的 MST.

Prim 算法: 不断增大与 MST 中已有顶点相邻且代价最小的边
> 假设 G=(V, E) 是一个具有 n 个顶点的连通网, T=(U, TE) 是 G 的 MST, 其中 U 是 T 的顶点集, TE 是 T 的边集, U 和 TE 初值均为空. 首先从 V 中任取一个顶点 v1, 将它并入 U 中, 此时 U={v1}. 然后只要 U 是 V 的真子集, 就从那些一个端点已在 T 中, 另一个端点仍在 T 外的所有边中, 找一条最短 (权值最小) 边, 假定为 (vi, vj), 其中 vi ∈ U, vj ∈ V-U, 并把该边和顶点 vj 分别并入 TE 和 U, 如此进行下去, 直到 n-1 次后把所有顶点都并入到 T 的顶点集 U 中.

Kruskal 算法: 不断合并边
> 假设 G=(V, E) 是一个有 n 个顶点的连通网, T=(U, TE) 是 G 的 MST, U 的初值等于 V, T 的初始状态是只含有 n 个顶点而无边的森林 T=(V, ∅). 将 G 中的边按权值从小到大依次选取 E 中的边, 若选取的边使 T 不形成环路, 则并入 TE; 若形成环路, 则舍弃. 如此进行直到 TE 中包含 n-1 条边为止.
> 由于一个网中会有权值相同的边, 从不同点出发可以得到不同的 MST

## 最短路径

从一个顶点到另一个顶点路径中, 所经边的权值之和最小的路径即 **最短路径**.

**单源最短路径问题**: 求从源点到图中其余各顶点的最短路径. **多源最短路径问题** 可用每个顶点作为源点调用一次单源最短路径问题算法求解.

Dijkstra 算法: 按路径长度递增顺序产生各顶点的最短路径:
> 设有向图 G=(V, E), 其中 V={1, 2, ..., n}. cost 表示 G 的邻接矩阵, cost[i][j] 表示有向边 <i, j> 的权. 若不存在有向边 <i, j>, 则 cost[i][j] 的权为无穷大. 设 S 是一个集合, 其中每个元素表示一个顶点, 从源点到这些顶点的最短距离已经求出. 设 v1 为 源点, S 初始只包含 v1. 数组 dist 记录从源点到其他各顶点当前的最短距离, 其初值为 dist[i]=cost[v1][i], i=2, ..., n. 从 S 之外的顶点集合 V-S 中选出一个顶点 w, 使 dist[w] 的值最小. 从源点到达 w 只通过 S 中的顶点, 把 w 加入集合 S 并调整 dist 中记录的距离, 即从原来的 dist[v] 和 dist[w]+cost[w][v] 中选出较小值作为新的 dist[v]. 重复上述过程, 直到 S 中包含 V 中其余顶点的最短路径.

> 算法的最终结果为:
> - S 记录了从源点到该顶点存在最短路径的顶点集合
> - dist 记录了从源点到 V 中各顶点之间的最短路径长度
> - path 是最短路径的路径数组, 其中 path[i] 表示从源点到顶点 i 的最短路径上顶点的前驱顶点

## 拓扑排序

把顶点表示活动, 边表示活动先后关系的有向无环图 (DAG) 称为顶点活动图 (AOV 网). 所有的活动排成一个线性序列, 使得每个活动的所有前趋活动都排在该活动前面, 次序列就是 **拓扑序列**. 求次序列的过程称为 **拓扑排序**.

拓扑排序:
1. 在图中选取一个没有前趋 (入度为零) 的顶点, 输出它
2. 从图中删除该顶点及与该顶点有关的所有边
3. 重复上述过程, 直到全部顶点都已输出, 或剩余顶点中没有入度为零的顶点为止
4. 输出剩余顶点

对给定的 AOV 网, 应首先判定网中是否存在环. 检测的方法是对有向图构造其顶点的拓扑序列, 若网中所有顶点都在它的拓扑序列中, 则该 AOV 网必定不存在环.

